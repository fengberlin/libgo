package zaplog

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"os"
	"time"
)

// logOptions specify the options for
// create a new logger.
// if you want to write log to file,
// you must set the the logPath. In most
// case, you can also set the serviceName
// to specify the directory where you log
// files are in.
type logOptions struct {
	serviceName      string
	logPath          string
	fileRotateMaxAge time.Duration
	fileRotationTime time.Duration
	logLevel         zapcore.Level
	development      bool
	addCaller        bool
	callerSkip       int
	addStacktrace    zapcore.LevelEnabler
	wrapCoreFunc     func(zapcore.Core) zapcore.Core
	hooks            []func(zapcore.Entry) error
	fields           []zap.Field
	errorOutput      zapcore.WriteSyncer
}

// defaultLogOptions is the default log options
var defaultLogOptions = logOptions{
	serviceName: "",
	logPath:     "",
	logLevel:    zapcore.DebugLevel,
	// 0 means the fileRotateMaxAge will default set to 7 * 24 * time.Hour
	fileRotateMaxAge: 0,
	// 0 means the fileRotationTime will default set to 24 * time.Hour
	fileRotationTime: 0,
	development:      false,
	addCaller:        true,
	callerSkip:       1,
	addStacktrace:    zapcore.ErrorLevel,
	// zap package internal error output
	errorOutput: os.Stderr,
}

type Option interface {
	apply(*logOptions)
}

type logOptionFunc func(*logOptions)

func (f logOptionFunc) apply(opt *logOptions) {
	f(opt)
}

// WithServiceName when in the production,
//the service name specify the the name of the log file dir name
func WithServiceName(serviceName string) Option {
	return logOptionFunc(func(o *logOptions) {
		o.serviceName = serviceName
	})
}

// WithLogPath will write log the the path
func WithLogPath(logPath string) Option {
	return logOptionFunc(func(o *logOptions) {
		o.logPath = logPath
	})
}

// WithLogLevel will set the log level to the given
// level and above
func WithLogLevel(logLevel zapcore.Level) Option {
	return logOptionFunc(func(o *logOptions) {
		o.logLevel = logLevel
	})
}

// WithFileRotateMaxAge creates a new Option that sets the
// max age of a log file before it gets purged from
// the file system.
func WithFileRotateMaxAge(maxAge time.Duration) Option {
	return logOptionFunc(func(o *logOptions) {
		o.fileRotateMaxAge = maxAge
	})
}

// WithRotationTime creates a new Option that sets the
// time between rotation.
func WithFileRotationTime(rotationTime time.Duration) Option {
	return logOptionFunc(func(o *logOptions) {
		o.fileRotationTime = rotationTime
	})
}

// Development puts the logger in development mode, which makes DPanic-level
// logs panic instead of simply logging an error.
func Development() Option {
	return logOptionFunc(func(o *logOptions) {
		o.development = true
	})
}

// AddCaller configures the Logger to annotate each message with the filename
// and line number of zap's caller.
func AddCaller() Option {
	return logOptionFunc(func(o *logOptions) {
		o.addCaller = true
	})
}

// AddCallerSkip increases the number of callers skipped by caller annotation
// (as enabled by the AddCaller option). When building wrappers around the
// Logger and SugaredLogger, supplying this Option prevents zap from always
// reporting the wrapper code as the caller.
func AddCallerSkip(skip int) Option {
	return logOptionFunc(func(o *logOptions) {
		o.callerSkip += skip
	})
}

// AddStacktrace configures the Logger to record a stack trace for all messages at
// or above a given level.
func AddStacktrace(lvl zapcore.LevelEnabler) Option {
	return logOptionFunc(func(o *logOptions) {
		o.addStacktrace = lvl
	})
}

// WrapCore wraps or replaces the Logger's underlying zapcore.Core.
func WrapCore(wrapCoreFunc func(zapcore.Core) zapcore.Core) Option {
	return logOptionFunc(func(o *logOptions) {
		o.wrapCoreFunc = wrapCoreFunc
	})
}

// WithHooks registers functions which will be called each time the Logger writes
// out an Entry. Repeated use of WithHooks is additive.
//
// WithHooks are useful for simple side effects, like capturing metrics for the
// number of emitted logs. More complex side effects, including anything that
// requires access to the Entry's structured fields, should be implemented as
// a zapcore.Core instead. See zapcore.RegisterHooks for details.
func WithHooks(hooks ...func(zapcore.Entry) error) Option {
	return logOptionFunc(func(o *logOptions) {
		o.hooks = hooks
	})
}

// WithFields adds fields to the Logger.
func WithFields(fields ...zap.Field) Option {
	return logOptionFunc(func(o *logOptions) {
		o.fields = fields
	})
}

// WithErrorOutput sets the destination for errors generated by the Logger. Note
// that this option only affects internal errors; for sample code that sends
// error-level logs to a different location from info- and debug-level logs,
// see the package-level AdvancedConfiguration example.
//
// The supplied WriteSyncer must be safe for concurrent use. The Open and
// zapcore.Lock functions are the simplest ways to protect files with a mutex.
func WithErrorOutput(w zapcore.WriteSyncer) Option {
	return logOptionFunc(func(o *logOptions) {
		o.errorOutput = w
	})
}
